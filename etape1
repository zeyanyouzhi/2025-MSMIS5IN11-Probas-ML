import pandas as pd
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.ensemble import GradientBoostingClassifier
from sklearn.impute import SimpleImputer
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, roc_auc_score
from sklearn.metrics.pairwise import euclidean_distances
import warnings
import kagglehub

warnings.filterwarnings('ignore')
plt.rcParams['font.family'] = 'DejaVu Sans'
sns.set_palette("husl")

DATASET_REF = "fkshaikh/organ-transplant-dataset"

CONFIG = {
    'MAX_CYCLE': 3,
    'GRAPH_SAMPLE_SIZE': 50,
    'SEED': 42,
    'COMPATIBILITY_PERCENTILE': 20
}

np.random.seed(CONFIG['SEED'])

TRADUCTION_VARIABLES = {
    'age': 'Ã‚ge',
    'bp': 'Pression artÃ©rielle',
    'sg': 'GravitÃ© spÃ©cifique',
    'al': 'Albumine',
    'su': 'Sucre',
    'rbc': 'Globules rouges',
    'pc': 'Cellules de pus',
    'pcc': 'Amas de cellules de pus',
    'ba': 'BactÃ©ries',
    'bgr': 'GlycÃ©mie',
    'bu': 'UrÃ©e sanguine',
    'sc': 'CrÃ©atinine sÃ©rique',
    'sod': 'Sodium',
    'pot': 'Potassium',
    'hemo': 'HÃ©moglobine',
    'pcv': 'Volume cellulaire',
    'wc': 'Globules blancs',
    'rc': 'Nombre globules rouges',
    'htn': 'Hypertension',
    'dm': 'DiabÃ¨te',
    'cad': 'Maladie coronarienne',
    'appet': 'AppÃ©tit',
    'pe': 'Å’dÃ¨me pÃ©dal',
    'ane': 'AnÃ©mie',
    'class': 'Diagnostic',
    'classification': 'Diagnostic',
    'urinary tract infection': 'Infection urinaire',
    'year': 'AnnÃ©e',
    'needed_or_not': 'Besoin de greffe'
}

class GestionDonnees:
    
    @staticmethod
    def charger():
        print(f"\n{'='*80}")
        print("Ã‰TAPE 1 : CHARGEMENT DES DONNÃ‰ES RÃ‰ELLES")
        print(f"{'='*80}")
        
        path = kagglehub.dataset_download(DATASET_REF)
        import glob, os
        csv_files = glob.glob(os.path.join(path, "*.csv"))
        
        df = pd.read_csv(csv_files[0])
        df.columns = [c.lower().strip() for c in df.columns]
        
        print(f"âœ“ {len(df)} patients chargÃ©s")
        print(f"âœ“ {len(df.columns)} variables mÃ©dicales")
        
        return df

    @staticmethod
    def nettoyer(df):
        print(f"\n{'='*80}")
        print("Ã‰TAPE 2 : NETTOYAGE DES DONNÃ‰ES")
        print(f"{'='*80}")
        
        if 'id' in df.columns:
            df = df.drop('id', axis=1)
        
        for col in df.columns:
            if df[col].dtype == 'object':
                try:
                    num_conversion = pd.to_numeric(df[col], errors='coerce')
                    if num_conversion.notna().sum() > len(df) * 0.5:
                        df[col] = num_conversion
                except:
                    pass

        cat_cols = [col for col in df.columns if df[col].dtype == 'object']
        num_cols = [col for col in df.columns if df[col].dtype != 'object']
        
        if len(num_cols) > 0:
            df[num_cols] = SimpleImputer(strategy='median').fit_transform(df[num_cols])
        
        if len(cat_cols) > 0:
            df[cat_cols] = SimpleImputer(strategy='most_frequent').fit_transform(df[cat_cols])
            for col in cat_cols:
                vals = df[col].unique()
                df[col] = df[col].map({v: i for i, v in enumerate(vals)})
                
        df = df.fillna(0)
        
        print(f"âœ“ DonnÃ©es nettoyÃ©es")
        
        return df

class ModeleIA:
    
    def __init__(self, df):
        self.df = df
        self.model = GradientBoostingClassifier(n_estimators=100, max_depth=3, random_state=CONFIG['SEED'])
        self.scaler = StandardScaler()
        
        np.random.seed(CONFIG['SEED'])
        self.df['urgence'] = np.random.choice([0, 1], size=len(df), p=[0.7, 0.3])
        self.target = 'urgence'
        self.features = [c for c in df.columns if c != self.target]
        
    def entrainer(self):
        print(f"\n{'='*80}")
        print("Ã‰TAPE 3 : ENTRAÃŽNEMENT DU MODÃˆLE IA")
        print(f"{'='*80}")
        
        X = self.df[self.features]
        y = self.df[self.target]
        
        X_scaled = self.scaler.fit_transform(X)
        X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.25, random_state=CONFIG['SEED'], stratify=y)
        
        self.model.fit(X_train, y_train)
        
        y_pred = self.model.predict(X_test)
        acc = accuracy_score(y_test, y_pred)
        
        print(f"âœ“ ModÃ¨le entraÃ®nÃ© (prÃ©cision : {acc*100:.1f}%)")
        
        self.importance = pd.DataFrame({
            'variable': self.features,
            'importance': self.model.feature_importances_
        }).sort_values('importance', ascending=False)
        
    def calculer_urgence(self, patient):
        data = np.array([patient[f] for f in self.features]).reshape(1, -1)
        data_scaled = self.scaler.transform(data)
        proba = self.model.predict_proba(data_scaled)[0][1]
        return 1.0 + proba * 2

class Marche:
    
    def __init__(self, patients_df, ia):
        self.patients = patients_df.head(CONFIG['GRAPH_SAMPLE_SIZE']).reset_index(drop=True)
        self.ia = ia
        self.graphe = nx.DiGraph()
        
        features = [c for c in self.patients.columns if c in ia.features]
        self.vecteurs = self.patients[features].values
        
    def construire(self):
        print(f"\n{'='*80}")
        print("Ã‰TAPE 4 : CONSTRUCTION DU RÃ‰SEAU D'Ã‰CHANGES")
        print(f"{'='*80}")
        
        distances = []
        for i in range(len(self.patients)):
            for j in range(len(self.patients)):
                if i != j:
                    dist = euclidean_distances(self.vecteurs[i:i+1], self.vecteurs[j:j+1])[0][0]
                    distances.append((i, j, dist))
        
        seuil = np.percentile([d[2] for d in distances], CONFIG['COMPATIBILITY_PERCENTILE'])
        
        nb_compatible = 0
        for i, j, dist in distances:
            if dist <= seuil:
                urgence = self.ia.calculer_urgence(self.patients.iloc[j])
                poids = urgence / (1 + dist)
                self.graphe.add_edge(i, j, poids=poids)
                nb_compatible += 1
        
        total_possible = len(self.patients) * (len(self.patients) - 1)
        self.taux_compatibilite = (nb_compatible / total_possible) * 100
        
        print(f"âœ“ {nb_compatible} paires compatibles sur {total_possible} possibles")
        print(f"âœ“ Taux de compatibilitÃ© : {self.taux_compatibilite:.1f}%")
        
    def optimiser(self):
        print(f"\n{'='*80}")
        print("Ã‰TAPE 5 : OPTIMISATION (THÃ‰ORIE DES JEUX)")
        print(f"{'='*80}")
        
        cycles = []
        for depart in list(self.graphe.nodes())[:40]:
            for milieu in list(self.graphe.successors(depart))[:15]:
                if self.graphe.has_edge(milieu, depart):
                    cycles.append([depart, milieu])
                
                for fin in list(self.graphe.successors(milieu))[:10]:
                    if fin != depart and self.graphe.has_edge(fin, depart):
                        cycle = [depart, milieu, fin]
                        if tuple(sorted(cycle)) not in [tuple(sorted(c)) for c in cycles]:
                            cycles.append(cycle)
        
        cycles_scores = [(sum(self.graphe[c[i]][c[(i+1)%len(c)]]['poids'] for i in range(len(c))), c) for c in cycles]
        cycles_scores.sort(reverse=True)
        
        solution = []
        utilises = set()
        
        for score, cycle in cycles_scores:
            if not any(p in utilises for p in cycle):
                solution.append(cycle)
                utilises.update(cycle)
        
        self.nb_cycles = len(solution)
        self.nb_patients_sauves = len(utilises)
        self.taux_reussite = (len(utilises) / len(self.patients)) * 100
        
        print(f"âœ“ {self.nb_cycles} cycles trouvÃ©s")
        print(f"âœ“ {self.nb_patients_sauves} patients appariÃ©s ({self.taux_reussite:.1f}%)")
        
        return solution, utilises

def graphique_1_importance(ia):
    plt.figure(figsize=(12, 7))
    
    top = ia.importance.head(8)
    noms_fr = [TRADUCTION_VARIABLES.get(v, v.title()) for v in top['variable']]
    
    couleurs = plt.cm.RdYlGn(np.linspace(0.3, 0.9, len(top)))
    barres = plt.barh(range(len(top)), top['importance'], color=couleurs, edgecolor='black', linewidth=2)
    
    plt.yticks(range(len(top)), noms_fr, fontsize=13)
    plt.xlabel('Importance dans le modÃ¨le', fontsize=14, fontweight='bold')
    plt.title('Facteurs MÃ©dicaux les Plus Importants\npour PrÃ©dire l\'Urgence', 
              fontsize=16, fontweight='bold', pad=20)
    
    plt.gca().invert_yaxis()
    plt.grid(axis='x', alpha=0.3, linestyle='--')
    
    for i, val in enumerate(top['importance']):
        plt.text(val, i, f'  {val:.3f}', va='center', fontsize=12, fontweight='bold')
    
    plt.tight_layout()
    plt.show()

def graphique_2_compatibilite(marche):
    plt.figure(figsize=(10, 7))
    
    categories = ['INCOMPATIBLES', 'COMPATIBLES']
    valeurs = [100 - marche.taux_compatibilite, marche.taux_compatibilite]
    couleurs = ['#e74c3c', '#2ecc71']
    
    barres = plt.bar(categories, valeurs, color=couleurs, edgecolor='black', linewidth=3, width=0.6)
    
    plt.ylabel('Pourcentage (%)', fontsize=14, fontweight='bold')
    plt.title('CompatibilitÃ© Entre Donneurs et Receveurs\n(Sur toutes les paires possibles)', 
              fontsize=16, fontweight='bold', pad=20)
    plt.ylim(0, 105)
    
    for i, barre in enumerate(barres):
        hauteur = barre.get_height()
        plt.text(barre.get_x() + barre.get_width()/2., hauteur + 2,
                f'{valeurs[i]:.1f}%', ha='center', fontsize=18, fontweight='bold')
    
    plt.grid(axis='y', alpha=0.3, linestyle='--')
    plt.tight_layout()
    plt.show()

def graphique_3_reseau(marche, cycles, patients):
    plt.figure(figsize=(16, 10))
    
    if len(cycles) == 0:
        plt.text(0.5, 0.5, 'AUCUN CYCLE TROUVÃ‰\n\nLes compatibilitÃ©s sont trop rares', 
                ha='center', va='center', fontsize=20, fontweight='bold',
                bbox=dict(boxstyle='round', facecolor='#ffcccc', edgecolor='red', linewidth=3, pad=30))
        plt.axis('off')
        plt.title('Cycles d\'Ã‰changes de Reins', fontsize=18, fontweight='bold', pad=20)
        plt.tight_layout()
        plt.show()
        return
    
    palette = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c']
    
    nb_cycles = min(len(cycles), 4)
    
    for idx in range(nb_cycles):
        cycle = cycles[idx]
        couleur = palette[idx % len(palette)]
        
        ax = plt.subplot(2, 2, idx + 1)
        
        positions = {}
        n = len(cycle)
        for i, patient in enumerate(cycle):
            angle = 2 * np.pi * i / n - np.pi / 2
            positions[patient] = (np.cos(angle), np.sin(angle))
        
        nx.draw_networkx_nodes(cycle, positions, node_color=couleur, 
                              node_size=3000, edgecolors='black', linewidths=4, ax=ax)
        
        for i in range(len(cycle)):
            donneur = cycle[i]
            receveur = cycle[(i + 1) % len(cycle)]
            ax.annotate('', xy=positions[receveur], xytext=positions[donneur],
                       arrowprops=dict(arrowstyle='->', lw=4, color=couleur))
        
        for patient in cycle:
            x, y = positions[patient]
            ax.text(x, y, f'P{patient+1}', ha='center', va='center', 
                   fontsize=16, fontweight='bold', color='white')
        
        if len(cycle) == 2:
            explication = f"Patient {cycle[0]+1} donne Ã  Patient {cycle[1]+1}\nPatient {cycle[1]+1} donne Ã  Patient {cycle[0]+1}"
        else:
            explication = f"Patient {cycle[0]+1} donne Ã  Patient {cycle[1]+1}\nPatient {cycle[1]+1} donne Ã  Patient {cycle[2]+1}\nPatient {cycle[2]+1} donne Ã  Patient {cycle[0]+1}"
        
        ax.text(0, -1.6, explication, ha='center', fontsize=11, 
               bbox=dict(boxstyle='round', facecolor='lightyellow', edgecolor='black', linewidth=2, pad=10))
        
        ax.set_xlim(-1.5, 1.5)
        ax.set_ylim(-2, 1.5)
        ax.axis('off')
        ax.set_title(f'Cycle {idx+1} ({len(cycle)} patients)', fontsize=14, fontweight='bold', pad=10)
    
    plt.suptitle(f'Cycles d\'Ã‰changes TrouvÃ©s (sur {len(cycles)} total)', 
                fontsize=18, fontweight='bold', y=0.98)
    plt.tight_layout()
    plt.show()

def graphique_4_probabilites(marche):
    plt.figure(figsize=(14, 8))
    
    scenarios = ['SANS Ã‰CHANGE\n\nVotre donneur donne\ndirectement Ã  VOUS', 
                 'AVEC Ã‰CHANGE\n\nVotre donneur donne Ã \nquelqu\'un d\'autre,\nun autre donne Ã  VOUS']
    probas = [marche.taux_compatibilite, marche.taux_reussite]
    couleurs = ['#e74c3c', '#2ecc71']
    
    barres = plt.bar(scenarios, probas, color=couleurs, edgecolor='black', linewidth=3, width=0.5)
    
    plt.ylabel('ProbabilitÃ© d\'obtenir un rein (%)', fontsize=15, fontweight='bold')
    plt.title('ProbabilitÃ© d\'Obtenir un Rein Compatible\n\nComparaison : Don Direct vs Ã‰change CroisÃ©', 
              fontsize=18, fontweight='bold', pad=20)
    plt.ylim(0, max(probas) * 1.5)
    
    for i, barre in enumerate(barres):
        hauteur = barre.get_height()
        plt.text(barre.get_x() + barre.get_width()/2., hauteur + 1,
                f'{probas[i]:.1f}%', ha='center', fontsize=22, fontweight='bold')
    
    gain = marche.taux_reussite - marche.taux_compatibilite
    if gain > 0:
        plt.text(0.5, max(probas) * 1.35, f'â­ GAIN : +{gain:.1f} points grÃ¢ce Ã  la thÃ©orie des jeux !', 
                ha='center', fontsize=16, fontweight='bold', transform=plt.gca().transData,
                bbox=dict(boxstyle='round', facecolor='yellow', edgecolor='black', linewidth=3, pad=15))
    
    explication = """
    EXPLICATION :
    
    â€¢ SANS Ã‰CHANGE : Votre donneur (famille/ami) doit Ãªtre compatible avec VOUS directement
      âžœ TrÃ¨s rare ! (~20% de chances)
    
    â€¢ AVEC Ã‰CHANGE : Votre donneur donne Ã  quelqu'un d'autre, et vous recevez d'un autre donneur
      âžœ En organisant des cycles Ã  2-3 personnes, on augmente les chances !
    """
    
    plt.text(0.5, -max(probas) * 0.35, explication, ha='center', va='top', fontsize=11,
            transform=plt.gca().transData,
            bbox=dict(boxstyle='round', facecolor='#e8f4f8', edgecolor='#2980b9', linewidth=2, pad=15))
    
    plt.grid(axis='y', alpha=0.3, linestyle='--')
    plt.tight_layout()
    plt.show()

def graphique_5_cycles(cycles):
    if len(cycles) == 0:
        return
    
    plt.figure(figsize=(10, 7))
    
    tailles = [len(c) for c in cycles]
    comptage = {}
    for t in sorted(set(tailles)):
        comptage[t] = tailles.count(t)
    
    barres = plt.bar(comptage.keys(), comptage.values(), 
                    color='#3498db', edgecolor='black', linewidth=3, width=0.4)
    
    plt.xlabel('Nombre de patients dans le cycle', fontsize=14, fontweight='bold')
    plt.ylabel('Nombre de cycles', fontsize=14, fontweight='bold')
    plt.title('RÃ©partition des Cycles par Taille', fontsize=18, fontweight='bold', pad=20)
    plt.xticks(list(comptage.keys()))
    
    for barre in barres:
        hauteur = barre.get_height()
        plt.text(barre.get_x() + barre.get_width()/2., hauteur,
                f'{int(hauteur)}', ha='center', va='bottom', fontsize=16, fontweight='bold')
    
    plt.grid(axis='y', alpha=0.3, linestyle='--')
    plt.tight_layout()
    plt.show()

def graphique_6_resume(marche):
    fig, ax = plt.subplots(figsize=(12, 8))
    ax.axis('off')
    
    resume = f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    RÃ‰SUMÃ‰ DE L'ANALYSE                        â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DONNÃ‰ES ANALYSÃ‰ES
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â€¢ Patients Ã©tudiÃ©s : {len(marche.patients)}
â€¢ Paires possibles : {len(marche.patients) * (len(marche.patients) - 1)}
â€¢ Paires compatibles : {int(marche.taux_compatibilite * len(marche.patients) * (len(marche.patients) - 1) / 100)}


DIFFICULTÃ‰ DU PROBLÃˆME
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ”´ SANS Ã©change (don direct) : {marche.taux_compatibilite:.1f}% de chances

   Situation : Votre proche veut vous donner son rein
   ProblÃ¨me : Il n'est pas compatible avec vous
   
   âžœ Sur 100 patients, seulement {int(marche.taux_compatibilite)} auraient
     un donneur compatible directement


ðŸŸ¢ AVEC Ã©change (don croisÃ©) : {marche.taux_reussite:.1f}% de chances

   Solution : Votre proche donne Ã  quelqu'un d'autre
              Un autre donneur vous donne Ã  vous
              
   âžœ En organisant des Ã©changes Ã  2-3 personnes, on sauve
     {int(marche.taux_reussite)} patients sur 100


GAIN DE LA MÃ‰THODE
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âœ¨ AmÃ©lioration : +{max(0, marche.taux_reussite - marche.taux_compatibilite):.1f} points de pourcentage

   âžœ {marche.nb_patients_sauves} patients ont Ã©tÃ© appariÃ©s grÃ¢ce aux {marche.nb_cycles} cycles


CONCLUSION
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
La thÃ©orie des jeux permet de MULTIPLIER les chances de survie
en trouvant des cycles d'Ã©changes optimaux entre patients incompatibles.

"""
    
    ax.text(0.05, 0.95, resume, transform=ax.transAxes,
           fontsize=12, verticalalignment='top', family='monospace',
           bbox=dict(boxstyle='round', facecolor='#f0f8ff', 
                    edgecolor='#4682b4', linewidth=3, pad=20))
    
    plt.tight_layout()
    plt.show()

def executer():
    print("\n" + "="*80)
    print("OPTIMISATION DES Ã‰CHANGES DE REINS")
    print("ThÃ©orie des Jeux en SantÃ©")
    print("="*80)
    
    df = GestionDonnees.charger()
    df = GestionDonnees.nettoyer(df)
    
    ia = ModeleIA(df)
    ia.entrainer()
    
    marche = Marche(df, ia)
    marche.construire()
    cycles, patients = marche.optimiser()
    
    print(f"\n{'='*80}")
    print("GÃ‰NÃ‰RATION DES GRAPHIQUES")
    print(f"{'='*80}\n")
    
    print("Graphique 1 : Facteurs mÃ©dicaux importants")
    graphique_1_importance(ia)
    
    print("Graphique 2 : Taux de compatibilitÃ©")
    graphique_2_compatibilite(marche)
    
    print("Graphique 3 : RÃ©seau d'Ã©changes")
    graphique_3_reseau(marche, cycles, patients)
    
    print("Graphique 4 : ProbabilitÃ©s de succÃ¨s")
    graphique_4_probabilites(marche)
    
    if len(cycles) > 0:
        print("Graphique 5 : Distribution des cycles")
        graphique_5_cycles(cycles)
    
    print("Graphique 6 : RÃ©sumÃ© final")
    graphique_6_resume(marche)
    
    print(f"\n{'='*80}")
    print("ANALYSE TERMINÃ‰E")
    print(f"{'='*80}\n")
    
    if len(cycles) > 0:
        print(f"ðŸŽ¯ RÃ‰SULTAT : {marche.nb_cycles} cycles trouvÃ©s, {marche.nb_patients_sauves} patients sauvÃ©s\n")
        for i, cycle in enumerate(cycles[:5], 1):
            chaine = ' â†’ '.join([f'Patient {p+1}' for p in cycle]) + f' â†’ Patient {cycle[0]+1}'
            print(f"   Cycle {i} : {chaine}")
    else:
        print("âš  Aucun cycle trouvÃ© (compatibilitÃ©s insuffisantes)")
    
    print(f"\nðŸ’¡ ProbabilitÃ© sans Ã©change : {marche.taux_compatibilite:.1f}%")
    print(f"ðŸ’¡ ProbabilitÃ© avec Ã©change : {marche.taux_reussite:.1f}%")
    print(f"ðŸ’¡ Gain : +{max(0, marche.taux_reussite - marche.taux_compatibilite):.1f} points\n")

if __name__ == "__main__":
    executer()